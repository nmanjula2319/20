Sequence
=========
Sequence is an object which is used to generate the numbers.

syntax:
	create sequence <sequence_name> start with value increment by value.
ex:
	create sequence sq1 start with 1 increment by 1;

	create sequence sq2 start with 10 increment by 10;

	create sequence sq3 start with 201 increment by 1;


We have two types of pseudo's in sequence.

1) NEXTVAL

2) CURRVAL

1) NEXTVAL
---------
It is used to generate next number in a sequence.
ex:
	create sequence sq1 start with 1 increment by 1;	

	drop table student;

	create table student(sno number(3),sname varchar2(10),sadd varchar2(12));

	insert into student values(sq1.NEXTVAL,'raja','hyd');
	insert into student values(sq1.NEXTVAL,'ravi','delhi');
	insert into student values(sq1.NEXTVAL,'ramana','vizag');	
	
	commit;

	select * from student;

2) CURRVAL
---------
It will return the last number which is generated by sequence.
ex:
	select sq1.CURRVAL from dual;


Q) Write a query to display list of sequences present in database?

	select sequence_name from user_sequences;


Q) Write a query to drop the sequence?

	drop sequence sq1;



Synonyms
=========
Alternate name given to a table is called synonym.

We can use synonym name instead of table name for all commands.

Using synonym name length of a table will reduce.

syntax:
	create synonym <synonym_name> for <object_name>;

ex:
	create synonym syn1 for student;

	select * from syn1;
	
	delete from syn1; // 3 records 

	select * from student; // no rows selected 


Q) Write a query to see the list of synonyms present in database?

	select synonym_name from user_synonyms;


Q) Write a query to drop the synonym ?

	drop synonym syn1;

Indexes
=======
Index is an object which is used to improve the performance of select command.

Index in a database is similar to index in a book.

We can create index only to those columns which are widely used in where clause.

When we create index, two columns will be created.One is ROWID and another is indexed column.
All the records will store in the form of ascending order in the indexed column. 

				Indexed table 
			------------------------------
			ROWID		indexed column
			------------------------------
				|	9000
				|	15000
				|	29000	
				|	37000
				|	45000
			------------------------------	

We have two types of index.

1) Simple index 
---------------
If a index is created only for one column is called simple index.

syntax:
-----
	create index  <index_name> on <table_name>(col_name);

ex:
	create index idx1 on emp(esal);

	select * from emp where esal=45000;

	Here index is used when we use that column in a where clause.

2) Complex index 
----------------
If index is created for multiple columns is called complex index.

syntax:
------
	create index <index_name> on <table_name>(col1,col2,..,colN);

ex:
	create index idx2 on emp(eid,deptno);

	select * from emp where eid=206 and deptno=30;

	Here index is used when we use two columns in a where clause.


Q) Write a query to display list of indexes present in database?

	select index_name from user_indexes;


Q) Write a query to drop the index?

	drop index idx1;
	drop index idx2;


Joins
======
select * from emp; // 6 records 

select * from dept; // 4  records 

select * from emp,dept; // 6*4= 24 records 

select eid,ename,esal,deptno,dname,dloc from emp,dept; // column ambiguously defined

To overcome above limitation we need to use table_name.column_name.
ex:
	select emp.eid,emp.ename,emp.esal,dept.deptno,dept.dname,dept.dloc from emp,dept;

table alias
============
A userdefined heading given to a table is called table alias.

Using table alias length of the query will reduce mean while performance is maintained.

ex:
	
	select e.eid,e.ename,e.esal,d.deptno,d.dname,d.dloc from emp e,dept d; // 6*4=24 records

Definition
===========
Joins are used to retrieve the data from one or more then one table.

We have different types of joins.

1) Equi Join 

2) Non-Equi Join 

3) Self Join 

4) Cartisian product 

5) Inner Join 

6) Outer Join 

1) Equi Join 
-----------
When two tables are joined based on common column is called equi join.

ex:
	select e.eid,e.ename,e.esal,d.dname,d.dloc from emp e,dept d
	where(e.deptno=d.deptno);// 6 records 

2) Non-Equi Join
------------------
When two tables are joined without using equi-join condition is called non-equi join.
ex:
	select e.eid,e.ename,e.esal,d.dname,d.dloc from emp e,dept d
	where e.esal>30000; // 3 * 4 = 12 records 


3) Self Join
--------------
When table joined to itself is called self join.

In self join we will create two table alias for same table.

ex:
--
	select e1.eid,e1.ename,e1.esal,e2.job,e2.comm from emp e1,emp e2
	where(e1.deptno=e2.deptno); //6 + 6 = 12 records 


4) Cartisian product
--------------------
It will return all possible combination.

In cartisian product we will not declare join condition.

ex:
	select e.eid,e.ename,e.esal,d.dname,d.dloc from emp e,dept d; // 6 * 4 = 24 records 

5) Inner Join
-------------
It is similar to equi join.

It is given by ANSII people.

American National Standard for Information Interchange.

ex:
	select e.eid,e.ename,e.esal,d.dname,d.dloc from emp e INNER JOIN dept d
	ON(e.deptno=d.deptno);// 6 records 


6) Outer Join 
-------------
It is extension of equi join.

It will return matching as well as not matching records.

A '+' symbol deonted as outer join operator.

We have following list of outer joins.

1) Left outer join
-------------------
	SQL
	----
		select e.eid,e.ename,e.esal,e.deptno,d.deptno,d.dname,d.dloc from emp e,dept d
		where(e.deptno=d.deptno(+));
		
	ANSII
	-----
		select e.eid,e.ename,e.esal,e.deptno,d.deptno,d.dname,d.dloc 
		from emp e LEFT OUTER JOIN dept d
		ON(e.deptno=d.deptno);


2) Right outer join 
-------------------
	SQL
	----
		select e.eid,e.ename,e.esal,e.deptno,d.deptno,d.dname,d.dloc from emp e,dept d
		where(e.deptno(+)=d.deptno);
		
	ANSII
	-----
		select e.eid,e.ename,e.esal,e.deptno,d.deptno,d.dname,d.dloc 
		from emp e RIGHT OUTER JOIN dept d
		ON(e.deptno=d.deptno);


3) Full outer join 
--------------
	ANSII
	-----
		select e.eid,e.ename,e.esal,e.deptno,d.deptno,d.dname,d.dloc 
		from emp e FULL OUTER JOIN dept d
		ON(e.deptno=d.deptno);






































	















